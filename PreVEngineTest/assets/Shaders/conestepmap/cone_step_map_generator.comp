#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform image2D outConeStepMap;

layout(binding = 1) uniform sampler2D heightMap;

layout(std140, binding = 2) uniform UniformBufferObject {
	vec4 resolution;
	vec4 oneOverResolution;
	uint searchStepCount;
	float onveOverSearchStepCount;
} uboCS;

float getH(in vec2 uv)
{
    return texture(heightMap, uv).r;
}

vec2 texCoord(in uvec2 texelInd)
{
    return (vec2(texelInd) + 0.5) * uboCS.oneOverResolution.xy;
}

float dot2(in vec2 a)
{
    return dot(a, a);
}

float getConservativeCone(in float baseHeight, in vec2 baseTexCoord, in vec2 uv)
{
    float d2 = dot2(baseTexCoord - uv);
    float deltaH = texture(heightMap, uv).r - baseHeight;
    return deltaH <= 0 ? 1.0 : sqrt(d2) / deltaH;
}

// Adapted from https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-18-relaxed-cone-stepping-relief-mapping
float getRelaxedCone(in float baseHeight, in vec2 baseTexCoord, in vec2 uv, in float minRatio)
{
    vec3 src = vec3(baseTexCoord, 1.0f + 0.001f);
    vec3 dst = vec3(uv.x, uv.y, texture(heightMap, uv));

    if ((dst.z <= baseHeight) || length(dst.xy - baseTexCoord) > minRatio * (dst.z - baseHeight))
	{
        return 1.0;
	}

    vec3 vec = dst - src; // Ray direction
    vec /= -vec.z; // Scale ray direction so that vec.z = -1.0
    vec *= dst.z; // Scale again
    vec3 step_fwd = vec * uboCS.onveOverSearchStepCount; // Length of a forward step
    // Search until a new point outside the surface
    vec3 ray_pos = dst + step_fwd;
    for (uint i = 1; i < uboCS.searchStepCount; ++i)
    {
        float current_height = getH(ray_pos.xy);
        if (current_height >= ray_pos.z)
        {
            ray_pos += step_fwd;
        }
        else
        {
            break;
        }
    }
    // Original texel depth
    float src_texel_height = baseHeight;
    // Compute the cone ratio
    float cone_ratio = (ray_pos.z <= src_texel_height) ? 1.0 : length(ray_pos.xy - baseTexCoord) / (ray_pos.z - src_texel_height);
    return cone_ratio;
}

float fakeCone(in float baseHeight, in vec2 baseTexCoord, in vec2 uv)
{
	float d2 = dot2(baseTexCoord - uv);
    return d2;
}

float getCone(in float baseHeight, in vec2 baseTexCoord, in vec2 uv, in float minRatio)
{
	// return fakeCone(baseHeight, baseTexCoord, uv);
    //return getConservativeCone(baseHeight, baseTexCoord, uv);
    return getRelaxedCone(baseHeight, baseTexCoord, uv, minRatio);
}

// [numthreads(16, 16, 1)]
// void main(uint3 threadId : SV_DispatchThreadID)
// {
//     if (any(threadId.xy >= maxSize))
//         return;
//     float2 baseT = texCoord(threadId.xy); // texture coords
//     float baseH = heightMap.Load(int3(threadId.xy, srcLevel));

//     //float maxCos = 0;
//     float minTan = 1;
//     uint w = maxSize.x;
//     uint h = maxSize.y;
//     for (uint i = 0; i < w; ++i)
//     {
//         for (uint j = 0; j < h; ++j)
//         {
//             uint2 id = uint2(i, j);
//             if (any(threadId.xy != id))
//             {
//                 minTan = min(minTan, getCone(baseH, baseT, id, minTan));

//             }
//         }
//     }
//     coneMap[threadId.xy] = float2(baseH, minTan);
// }

void main()
{
	ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
	if(fragCoord.x >= uboCS.resolution.x || fragCoord.y >= uboCS.resolution.y)
	{
		return;
	}

	vec2 baseT = texCoord(gl_GlobalInvocationID.xy);
    float baseH = texture(heightMap, gl_GlobalInvocationID.xy).r;

    float minTan = 1.0f;
    uint w = uint(uboCS.resolution.x);
    uint h = uint(uboCS.resolution.y);
    for (uint i = 0; i < w; ++i)
    {
        for (uint j = 0; j < h; ++j)
        {
            uvec2 id = uvec2(i, j);
            if (gl_GlobalInvocationID.x != id.x || gl_GlobalInvocationID.y != id.y)
            {
				vec2 uv = texCoord(id.xy);
                minTan = min(minTan, getCone(baseH, baseT, uv, minTan));
            }
        }
    }
	imageStore(outConeStepMap, fragCoord, vec4(baseH, minTan, 0.0f, 0.0f));
}
